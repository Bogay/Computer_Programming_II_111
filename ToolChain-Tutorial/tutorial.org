:REVEAL_PROPERTIES:
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_VERSION: 4
#+REVEAL_THEME: serif
:END:

* CMake Tutorial

** Introduction

CMake is a build automation which dedicate in building our program automatically. In this tutorial, we will introduce toolchain, Makefile and CMake.

You may consider why I have to understand these bureaucratic knowledge? Can't I just write some code, click a button to run my code and everything just work as expected?

The answer is not really. Understanding how to use build automation helps us deploy and distribute our program fast.

Imagine build automation didn't exist, we must write instructions for other developers who want to use our project so they can build, execute, and test our program. For those programmers, they have to waste time on reading and following our instruction  instead of taking advantage of their time on find ways to improve our project. For small projects with tens of files, the building steps may not be a lengthy procedure. But when the program become a large project like Linux Kernel and FreeBSD. It may be error prone and time consuming. The idea behind build automation is to solve this problem by reduce the procedure on building program.

We write some scripts to describe how to build our program, and the build automation execute these scripts automatically. In other programmers' sight, they just download our code base, type one or few lines of commands provided by build automation and finally get the program run. So, why not try some build automation to make things easier?  


** First step: Toolchain

Before learning how to write build automation scripts, we have to know how to run our program. Nowadays, details on compile our source code is hidden by a series of tools call toolchain. Then the question is what is toolchain? P.S. We will only talk about compiled programming languages like C, C++ and Rust in this tutorial.  

The basic concept of toolchain needs the following component:

1) Compiler: Program convert your C++ code to assembly code
2) Assembler: Program convert assembly code to machine code. This is the program we will finally get.
3) Linker: Program link your program with external library like standard library
4) Standard Library: Library for common use function and structure
5) Debugger: Program that use debug information or dynamic tracking

All of the above programs are combined as a toolchain. Most of the operating system providers provide their C/C++ toolchain for developers to build robust application for users.

The following table are toolchains provided by the popular OS.

| OS      | Toolchain |
| Windows | MSVC      |
| MacOS   | Clang     |
| Linux   | GCC       |

Take GCC for example, assume we have the following c code for our hello project:

#+BEGIN_SRC c
  // tutorial.c
  #include <stdio.h>

  int main() {
    printf("Hello World!");
  }
#+END_SRC

To let gcc toolchain generate executable file for the hello project, we just simply use the following command:

#+BEGIN_SRC bash
  gcc tutorial.c -o tutorial
#+END_SRC

Congratulation, we have just built our hello project. The functionalities of Compiler, Assembler, Linker, Standard Library is hidden by toolchain. All of things we need to know is toolchain will generate files that can be executed.

By using the following command, we can execute our program.

#+BEGIN_SRC bash
  ./tutorial
#+END_SRC

It seems that we don't need any build automation, right? No.

Imagine the following directory layout is our project:

#+BEGIN_SRC bash
  hello-project/
    liba/
      a.c
      b.c
    libb/
      a.c
      b.c
    libc/
      a.c
      b.c
    main.c
    Makefile
#+END_SRC

Besides these file, assume that libb needs to use functions from liba, libc needs to use functions from libb and liba.

You may try to write the building instruction as follow:

#+BEGIN_SRC bash
  mkdir target
  gcc liba/a.c libb/b.c -c -o target/liba
  gcc libb/a.c libb/b.c target/liba -c -o target/libb
  gcc libc/a.c libc/b.c target/liba target/libb -c -o target/libc
  gcc target/liba target/libb/ target/libc main.c -o target/hello
#+END_SRC

Due to the library dependencies, we cannot change the command order. So anybody who miss any line of command will fail on build project. It is also an easy example? Ok. Try to type commands to build a project contains liba to libz with many dependencies. At this time, I think you may want to give up.

Obviously, when the project size become more and more big. Hand-typing building steps is not a practical solution to distribute our software. So in the next section we will introduce the basic build automation "Make" for C/C++.

* Second step: The Makefile build automation

Makefile is a traditional build automation in C/C++ but is not the main focus in this lecture. To get more information, I recommend you to take a look in this [[https://seisman.github.io/how-to-write-makefile/][site]]. This section will only introduce the basic concept of makefile.
Let's begin with a simple example. The following is the directory structure of our project.

#+BEGIN_SRC bash
  liba/
    a.c
  main.c
  Makefile
#+END_SRC

The following is the Makefile of the project

#+BEGIN_SRC C 
  all: liba
    gcc target/liba main.c -o hello
    mv hello target/hello
  liba:
    gcc -c -o target/liba liba/a.c 
#+END_SRC

To build the whole project, we just need to use the following command

#+BEGIN_SRC bash
  make
#+END_SRC

Boom, you just build the whole project.

Next, let's dive into to the structure of our makefile

#+BEGIN_SRC C
  <target> : <dependencies>
    <commands>
#+END_SRC

The target is the name of of the rule. Each target in makefile is a rule. In example, we have two rules, all and liba. "All" is the default rule.
If we want to build liba standalone, we can use the following command.

#+BEGIN_SRC bash
  make liba
#+END_SRC

The make program will build liba and solve all dependencies on liba.

The dependencies can not only a target but also a file. For example, the following rule is valid.

#+BEGIN_SRC C
  test: test.c test.h
    gcc test.c -c -o test
#+END_SRC

By using a file as dependency, it will check the last modify time of the file. If the time is late than what makefile record. It will recompile. In cotroversy, it will not build again to save time.
As the information give above, we can write makefile for hello-project as following.

#+BEGIN_SRC C
  all: liba libb libc
    gcc target/liba target/libb target/libc main.c -o target/hello
  liba:
    gcc liba/a.c libb/b.c -c -o target/liba
  libb: liba
    gcc target/liba libb/a.c libb/b.c -c -o target/libb
  libc: liba libb
    gcc target/liba target/libb libc/a.c libc/b.c -c -o target/libc
#+END_SRC

For other people build our program, the just need to type the following command and will get the final program.

#+BEGIN_SRC bash
  make
#+END_SRC

In this time, compare with last section, we solve two problems.

1) Makefile writter don't have to be bother from the dependency, all of the dependency will be solved automatically if we write the rule properly.
2) Other people don't need to following the lengthy instructions. They just need a simple instruction. Make.

But at the same time, we are not satisfy with the hand writting depenedency rule. We are consider that if there are some tools can generate dependencies automatically.
Yes, we have CMake. What we want to introduce in the next section.

* Finally: The CMake build automation

Cmake is the tool that can generate Makefile automatically. The instruction of CMake is simple to understand. Let's take hello-project as example:

#+BEGIN_SRC CMake
  cmake_minimum_required(VERSION 3.1)

  project(hello VERSION 1.0)

  add_library(liba liba/a.c liba/b.c)
  add_library(libb liba libb/a.c libb/b.c)
  add_library(libc liba libb libc/a.c libc/b.c)

  add_executable(hello main.c)

  target_link_libraries(hello PRIVATE liba libb libc)
#+END_SRC

Save the file as CMakeLists.txt.
The focus on cmake is add_library, add_executable and link_libraries directives.
These three directives are start with the target name appended with several source files or targets.
We use add_library to add three libraries and appended with the correct source files and targets.
Then we add an executable which contain main.c as source file and liked with liba libb libc.
As you can see, we don't write any command this time. We just describe what libraries we have and what the source file is. All of the targets in the Makefile are generated automatically.

To run cmake, we use the following command:

#+BEGIN_SRC bash
  cd target
  cmake ..
#+END_SRC

It will generate Makefile acording to our CMakeLists.txt. Then we can run:

#+BEGIN_SRC bash
  make
#+END_SRC

To generate the program for us.
